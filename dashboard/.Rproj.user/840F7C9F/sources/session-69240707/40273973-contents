---
title: 'STAT 219 Spatial Statistics'
subtitle: 'Geostatistical Data'
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

remove(list=ls())
cat('\014')

# Load packages
packs <- c()
lapply(packs, require, character.only = TRUE)
```
<br/> 

<center> 
### Block 2a: Spatial Interpolation
**Example: Property Cost in Greece**
</center>
<br/> 
To illustrate the spatial interpolation methods, we would like to predict the prices of properties continuously in space in Athens, Greece. The *properties* data available in the *spData* package (Bivand, Nowosad, and Lovelace 2022) contains the price of apartments in Athens, Greece, in 2017. The  *depmunic* object, also in the *spData* package contains the administrative divisions boundary map for this study region.
<br/>

##### 1. Explore the dataset:
```{r Explore dataset:}
# Data: Requires package spData
?properties
properties.sf <- spData::properties

# Boundary map of study region: Requires spData
?depmunic
athens <- st_union(spData::depmunic) %>% st_sf()

# Plot points within boundary
p0

```

##### 2. Create a prediction grid:
```{r Create a prediction grid, fig.align='center'}
# Create a raster grid covering the study region
 
# Extract the coordinates of all cells

# Transform xy data frame to sf object and assign CRS

# Trim grid to study region

# Plot prediction grid
 
```

##### 3. Method 1: Closest Observation 
```{r Interpolation: Closest Observation, fig.align='center'}
# Voronoi diagram

# Extract the predicted values at prediction points 

# Plot of interpolated data
p1  

```

##### 4. Method 2: Inverse Distance Weighting
```{r Interpolation: Inverse Distance Weighting, fig.align='center'}
?gstat
idw <- gstat::gstat(formula = prpsqm ~ 1, locations = properties.sf,
             nmax = nrow(properties.sf), # use all the neighbors locations
             set = list(idp = 1)) # beta = 1

# Interpolate

# Plot of interpolated data
p2  

```

##### 5. Method 3: Nearest Neighbor
```{r Interpolation: Nearest Neighbor, fig.align='center'}
nn <- gstat::gstat(formula = prpsqm ~ 1, locations = properties.sf, nmax = 5,
                   set = list(idp = 0))

# Interpolate 

# Plot of interpolated data
p3  
 
```

##### 6. Weighted Combination of Methods
```{r Interpolation: Weighted Combination of Methods, fig.align='center'}
# Create data frame
x = st_coordinates(pred.locations)[, 1]
y = st_coordinates(pred.locations)[, 2]
weights <- c(1/3, 1/3, 1/3)
weighted.price =  co.sf$pred.psqm * weights[1] + idw.sf$pred.psqm * weights[2] + nn.sf$pred.psqm * weights[3]
weight.df <- data.frame(x,y,weighted.price)
 
# Transform data frame to sf object
 
# Plot of interpolated data
p4  
```

```{r Compare approaches, fig.align='center'}
# Compare approaches
gridExtra:: grid.arrange(p1, p2, p3, p4, ncol=2, nrow=2)
```

<center> 
**END**
</center>